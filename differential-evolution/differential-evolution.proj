<project target_env="C++"><configuration><parameter default="0" description="&quot;bool value&quot;" name="randomized" policy="optional" type="int" /><parameter default="10" description="size of dimension" name="dim" policy="mandatory" type="int" /><parameter default="100" description="number of populations" name="pop" policy="mandatory" type="int" /><parameter default="1000" description="count of generations" name="gen" policy="mandatory" type="int" /><parameter default="0.9" description="a mutation constant" name="F" policy="optional" type="double" /><parameter default="0.9" description="a crossover constant" name="C" policy="optional" type="double" /><parameter default="0" description="" name="max_time" policy="optional" type="int" /><parameter default="-1" description="" name="print_frequency" policy="optional" type="int" /><parameter default="ackley" description="an optimized function" name="function" policy="mandatory" type="std::string" /><parameter default="0" description="" name="eval" policy="mandatory" type="int" /><parameter default="4" description="exchange gap" name="gap" policy="mandatory" type="int" /><build-option name="CC">g++</build-option><build-option name="LIBS" /><build-option name="CFLAGS">-O2 -I /home/sur096/projects/kaira_projects/differential-evolution</build-option><build-option name="OTHER_FILES">arg/utils/rng/cStandardRng.cpp
arg/utils/rng/cRanlux.cpp
arg/utils/cRandom.cpp
arg/utils/cCLParser.cpp
arg/core/cDebuggable.cpp
arg/core/cAmphorA.cpp
arg/algorithms/de/cParallelDE.cpp
arg/algorithms/de/cDE.cpp
cFunctions.cpp
de/cFuncDE.cpp</build-option><head-code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;cstdio&gt;

#include &lt;arg/utils/cCLParser.h&gt;
#include &lt;arg/core/cAmphorA.h&gt;
#include &lt;cFunctions.h&gt;
#include &lt;de/cFuncDE.h&gt;

#include &lt;arg/utils/rng/cRanlux.h&gt;

struct Best {

	Best() {
		vector_length = 0;
		fitness_length = 0;
		fitness = NULL;
		vector = NULL;
	}

	Best(int vector_length, int fitness_length, double *vector, double *fitness) {
		this-&gt;vector_length = vector_length;
		this-&gt;fitness_length = fitness_length;
		this-&gt;vector = new double[vector_length];
		memcpy(this-&gt;vector, vector, vector_length*sizeof(double));
		this-&gt;fitness = new double[fitness_length];
		memcpy(this-&gt;fitness, fitness, fitness_length*sizeof(double));
	}

	Best(const Best &amp;best) {
		vector_length = best.vector_length;
		fitness_length = best.fitness_length;
		vector = new double[vector_length];
		memcpy(vector, best.vector, vector_length*sizeof(double));
		fitness = new double[fitness_length];
		memcpy(fitness, best.fitness, fitness_length*sizeof(double));
	}

	Best&amp; operator=(const Best &amp;best) {
		if (vector != NULL) {
			delete [] vector;
		}

		if (fitness != NULL) {
			delete [] fitness;
		}
		vector_length = best.vector_length;
		fitness_length = best.fitness_length;
		vector = new double[vector_length];
		memcpy(vector, best.vector, vector_length*sizeof(double));
		fitness = new double[fitness_length];
		memcpy(fitness, best.fitness, fitness_length*sizeof(double));

		return *this;
	}

	~Best() {
		if (vector != NULL) {
			delete [] vector;
			vector = NULL;
		}
		if (fitness != NULL) {
			delete [] fitness;
			fitness = NULL;
		}
	}

	int vector_length;
	int fitness_length;
	double *vector;
	double *fitness;
};

typedef cFuncDE* Island;

/*int get_next(const ca::Context &amp;ctx, const int *waited) {
	return (ctx.process_id() + 1) % ctx.process_count();
}*/

double traceFitness(const Island island) {
	return island-&gt;BestFitness();
}

double traceValue(const int value) {
	return value;
}

double traceAvgFitness(const Best best) {
	double sum = 0.0;
	for (int i = 0; i &lt; best.fitness_length; i++) {
		sum += best.fitness[i];
	}
	return sum / best.fitness_length;
}

bool contains(const int value, const std::vector&lt;int &gt; list) {
	int size = list.size();
	for (int i = 0; i &lt; size; i++) {
		if (value == list[i]) {
			return true;
		}
	}
	return false;
}

namespace ca {
	std::string token_name(const Island &amp;island) {
		return "Island";
	}

	std::string token_name(const Best &amp;best) {
		return "Best";
	}

	void pack(Packer &amp;packer, Best &amp;best) {
		pack(packer, best.vector_length);
		pack(packer, best.fitness_length);
		pack(packer, best.vector, best.vector_length*sizeof(double));
		pack(packer, best.fitness, best.fitness_length*sizeof(double));
	}

	template&lt;&gt; Best unpack(Unpacker &amp;unpacker) {
		int vector_length = unpack&lt;int&gt;(unpacker);
		int fitness_length = unpack&lt;int&gt;(unpacker);

		double *v = (double *) unpack(unpacker, vector_length*sizeof(double));
		double *f = (double *) unpack(unpacker, fitness_length*sizeof(double));

		Best best(vector_length, fitness_length, v, f);
		return best;
	}
}</head-code></configuration><net id="101" name="Main" net-type="main"><edge from_item="107" id="111" to_item="110"><inscription x="60.0" y="-300.0">c</inscription><point x="0" y="-286" /></edge><edge from_item="122" id="124" to_item="116"><inscription x="532.178029736" y="-203.995015572">vec</inscription></edge><edge from_item="116" id="126" to_item="102"><inscription x="565.551271466" y="-33.8504238219">island</inscription><point x="630" y="-18" /><point x="-232" y="-17" /><point x="-233" y="-163" /></edge><edge from_item="102" id="128" to_item="127"><inscription x="-270.999524127" y="-223.487809521">island</inscription></edge><edge from_item="107" id="129" to_item="127"><inscription x="-180.0" y="-318.0">c</inscription><point x="-64" y="-304" /><point x="-288" y="-304" /></edge><edge from_item="110" id="131" to_item="107"><inscription x="24.0" y="-240.0">c+1</inscription><point x="96" y="-222" /></edge><edge from_item="107" id="109" to_item="103"><inscription x="-36.0" y="-144.0">c</inscription><point x="-30" y="-162" /></edge><edge from_item="103" id="108" to_item="107"><inscription x="-83.7139067635" y="-174.715233091">c+1</inscription><point x="-96" y="-144" /></edge><edge bidirectional="true" from_item="102" id="105" to_item="103"><inscription x="-156.0" y="-108.0">island</inscription><point x="-168" y="-90" /></edge><edge from_item="127" id="134" to_item="133"><inscription x="-382.470617341" y="-168.496283065">vec@0</inscription></edge><edge from_item="133" id="136" to_item="135"><inscription x="-372.0" y="6.0">[bulk, guard(size == ctx.process_count())] vectors</inscription></edge><edge from_item="102" id="140" to_item="110"><inscription x="-194.0" y="-60.0">island</inscription><point x="-210" y="-108" /><point x="-210" y="-48" /><point x="168" y="-48" /></edge><edge bidirectional="true" from_item="142" id="145" to_item="110"><inscription x="174.0" y="-354.0">[bulk] waited</inscription></edge><edge from_item="127" id="146" to_item="142"><inscription x="-174.0" y="-420.0">[multicast] ctx.process_id()@all</inscription><point x="-384" y="-400" /></edge><edge from_item="142" id="148" to_item="135"><inscription x="590.188430868" y="32.000180117">[bulk] process_id</inscription><point x="704" y="-400" /><point x="708" y="48" /></edge><edge from_item="110" id="153" to_item="152"><inscription x="238.068425772" y="-247.606448621">island</inscription></edge><edge from_item="110" id="157" to_item="156"><inscription x="208.0" y="-304.0">vec@ to_next</inscription></edge><edge from_item="156" id="160" to_item="158"><inscription x="352.0" y="-304.0">[bulk] sended</inscription></edge><edge from_item="158" id="161" to_item="122"><inscription x="484.465224002" y="-240.494911085">vec</inscription></edge><edge from_item="152" id="163" to_item="158"><inscription x="348.0" y="-204.0">island</inscription><point x="390" y="-186" /></edge><edge from_item="158" id="165" to_item="164"><inscription x="544.0" y="-304.0">island</inscription></edge><edge from_item="164" id="166" to_item="116"><inscription x="630.0" y="-246.0">island</inscription></edge><area id="104" sx="192" sy="80" x="-208" y="-256"><init x="-208" y="-271">ca::range(0, ctx.process_count())</init></area><place id="102" name="Init" radius="20" sx="0" sy="0" x="-176" y="-224"><place-type x="-159.0" y="-207.0">Island</place-type><init x="-159.0" y="-254.0" /><code>	cFunctions func;
	func.SetFunction(cFunctions::FUNC_ACKLEY);

	if (!param::randomized()) {
		//arg::cStaticRandom::Seed(12349990);
		unsigned int seed[] = { 1, 2, 3, 4, 5, 10, 22, 35, 7, 1, 1 };
		
		arg::cStaticRandom::Seed(
			(unsigned int *) seed, 
			(unsigned int) sizeof(seed) / sizeof(unsigned int));
	}

	if (param::function() == "rastrigin") {
		func.SetFunction(cFunctions::FUNC_RASTRIGIN);
	} else if (param::function() == "dejong") {
		func.SetFunction(cFunctions::FUNC_DEJONG);
	} else if (param::function() == "griewank") {
		func.SetFunction(cFunctions::FUNC_GRIEWANK);
	} else if (param::function() == "ackley") {
		func.SetFunction(cFunctions::FUNC_ACKLEY);
	} else if (param::function() == "easom") {
		func.SetFunction(cFunctions::FUNC_EASOM);
	} else if (param::function() == "schwefel") {			
		func.SetFunction(cFunctions::FUNC_SCHWEFEL);
	} else if (param::function() == "rosenbrock") {
		func.SetFunction(cFunctions::FUNC_ROSENBROCK);
	}

	Island island;
	// initialization setting
	island = new cFuncDE(param::pop(), param::dim());
	island-&gt;Debug(false);
	island-&gt;MaxGenerations(param::gen());
	island-&gt;MaxEvaluations(param::eval());

	island-&gt;SetRange(func.RangeMin(), func.RangeMax());
	island-&gt;PrintFrequency(param::print_frequency());
	island-&gt;MaxTime(param::max_time());

	/*if (ctx.process_id() == 1) {
		island-&gt;F(0.3);
		island-&gt;C(0.8);
	} else if (ctx.process_id() == 2) {
		island-&gt;F(0.5);
		island-&gt;C(0.83);
	} else if (ctx.process_id() == 3) {
		island-&gt;F(0.7);
		island-&gt;F(0.86);
	} else {*/
		island-&gt;F(param::F()); // 0.9
		island-&gt;C(param::C()); // 0.9
	//}

	// init de
	island-&gt;Init();

	place.add(island);
</code></place><place id="107" name="counter" radius="20" sx="0" sy="0" x="-64" y="-224"><place-type x="-47.0" y="-207.0">int</place-type><init x="-42" y="-246">[1]</init><trace name="traceValue" return-type="int" /></place><place id="122" name="" radius="20" sx="0" sy="0" x="486" y="-192"><place-type x="503.0" y="-175.0">Best</place-type><init x="503.0" y="-222.0" /><code>	
</code><trace name="traceAvgFitness" return-type="double" /></place><place id="133" name="" radius="20" sx="0" sy="0" x="-384" y="-112"><place-type x="-367.0" y="-95.0">Best</place-type><init x="-367.0" y="-142.0" /></place><place id="142" name="stack" radius="20" sx="0" sy="0" x="160" y="-400"><place-type x="177.0" y="-383.0">int</place-type><init x="177.0" y="-430.0" /></place><place id="152" name="" radius="20" sx="0" sy="0" x="318" y="-186"><place-type x="335.0" y="-169.0">Island</place-type><init x="335.0" y="-216.0" /><trace name="ca::token_name" return-type="std::string" /></place><place id="156" name="" radius="20" sx="0" sy="0" x="320" y="-288"><place-type x="337.0" y="-271.0">Best</place-type><init x="337.0" y="-318.0" /><trace name="traceAvgFitness" return-type="double" /></place><place id="164" name="" radius="20" sx="0" sy="0" x="624" y="-288"><place-type x="640" y="-272">Island</place-type><init x="641.0" y="-318.0" /><trace name="ca::token_name" return-type="std::string" /></place><transition id="110" name="send" sx="70" sy="35" x="128" y="-304"><guard x="168" y="-324">c % param::gap() == 0 &amp;&amp; ctx.process_count() &gt; 1</guard><code>	arg::cArrayConst&lt;arg::cDE::t_FitnessIndexPair&gt; vector_info;
	var.island-&gt;SortPopulation(vector_info);

	int count = param::pop() * 0.1;
	var.vec.vector_length = param::dim() * count;
	var.vec.fitness_length = count;
	double *v = new double[var.vec.vector_length];
	double *f = new double[var.vec.fitness_length];
	double *pv = v;
	for (int i = 0; i &lt; count; i++) {
		f[i] = vector_info[i].fit;
		memcpy(pv, var.island-&gt;KairaGetArray(vector_info[i].idx), param::dim()*sizeof(double));
		pv += param::dim();
	}
	var.vec.vector = v;
	var.vec.fitness = f;
	
	
	// computes where to send data
	int i = 1;
	int next = (ctx.process_id() + i) % ctx.process_count();
	
	if (!var.waited.is_empty()) {
		/*for (ca::Token&lt;int &gt; *t = var.waited.begin(); t != NULL; t = var.waited.next(t)) {
			printf("%d, ", t-&gt;value);
		}*/
		//printf("\ncurrent: %d, next: %d\n", ctx.process_id(), next);
		while (contains(next, var.waited.to_vector())) {
			i++;
			next = (ctx.process_id() + i) % ctx.process_count();
			//printf("current: %d, next: %d\n", ctx.process_id(), next);
		}
		//printf("-&gt;&gt;current: %d, next: %d\n", ctx.process_id(), next);
		//printf("\n");
	}
	var.to_next = next;
	
	/*i = 1;
	int previous = (((ctx.process_id() - i) % ctx.process_count()) + ctx.process_count()) % ctx.process_count();
	if (!var.waited.is_empty()) {
		while (contains(previous, var.waited.to_vector())) {
			i++;
			previous = (((ctx.process_id() - i) % ctx.process_count()) + ctx.process_count()) % ctx.process_count();
		}
	}
	var.to_prev = previous;*/
</code></transition><transition id="116" name="exchange" sx="70" sy="35" x="592" y="-208"><guard x="592" y="-228" /><code>	var.island-&gt;KairaIntegrateVector(var.vec.vector, var.vec.fitness);
</code></transition><transition id="127" name="collect data" sx="70" sy="35" x="-416" y="-240"><guard x="-480" y="-258">c &gt; param::gen()</guard><code>	arg::cArrayConst&lt;double&gt; winner = var.island-&gt;Winner();
	var.vec.vector_length = winner.Count();
	var.vec.fitness_length = 1;
	double *v = new double[var.vec.vector_length];
	memcpy(v, winner.GetArray(0), var.vec.vector_length*sizeof(double));
	var.vec.vector = v;
	double *f = new double[var.vec.fitness_length];
	f[0] = var.island-&gt;BestFitness();
	var.vec.fitness = f;
	
	// send to all processes
	for (unsigned int i = 0; i &lt; ctx.process_count(); i++) {
		var.all.push_back(i);
	}

	var.island-&gt;Finalize();
	delete var.island;
</code></transition><transition id="103" name="compute" sx="70" sy="35" x="-102" y="-108"><guard x="-48" y="-126">c &lt;= param::gen() &amp;&amp; ((c % param::gap()) != 0 || ctx.process_count() == 1)</guard><code>	var.island-&gt;KairaExecute();
</code></transition><transition id="135" name="write result" sx="70" sy="35" x="-416" y="32"><guard x="-416" y="12" /><code>	double *best_solution;
	double fitness = -1;
	int length;
	for (ca::Token&lt;Best &gt; *t = var.vectors.begin(); t != NULL; t = var.vectors.next(t)) {
		if (fitness &gt; t-&gt;value.fitness[0] || fitness == -1) {
			fitness = t-&gt;value.fitness[0];
			best_solution = t-&gt;value.vector;
			length = t-&gt;value.vector_length;
		}
	}

	// print
	std::cout &lt;&lt; "Fitness = " &lt;&lt; fitness &lt;&lt; std::endl;
	std::cout &lt;&lt; "[";
	for (int i = 0; i &lt; length; i++) {
		std::cout &lt;&lt; best_solution[i] &lt;&lt; " ";
	}
	std::cout &lt;&lt; "]" &lt;&lt; std::endl;

	/*// write best-vector into file
	std::ofstream best_vector;
	best_vector.open("best-vector.csv", std::ios::out | std::ios::app);
	for (unsigned int i = 0; i &lt; length - 1; i++) {
		best_vector &lt;&lt; best_solution[i] &lt;&lt; ",";	
	}
	best_vector &lt;&lt; best_solution[length -1] &lt;&lt; "\n";
	best_vector.close();*/
	ctx.quit();
</code></transition><transition id="158" name="producer" sx="70" sy="35" x="448" y="-304"><guard x="448" y="-324" /><code>	if (!var.sended.is_empty()) {
		var.vec = var.sended.begin()-&gt;value;
	} else {
		int count = param::pop() * 0.1;
		int v_length = param::dim() * count;
	
		double *v = new double[v_length];
		memset(v, 0, v_length * sizeof(double));
	
		double *f = new double[count];
		for (int i = 0; i &lt; count; i++) {
			f[i] = 1e6;
		}
		var.vec.vector_length = v_length;
		var.vec.fitness_length = count;
		var.vec.vector = v;
		var.vec.fitness = f;
	}
</code></transition><area id="168" sx="0.0" sy="1.0" x="-134.0" y="-246.5"><init x="-134.0" y="-261.5" /></area></net></project>
