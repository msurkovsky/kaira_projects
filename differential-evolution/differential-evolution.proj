<project target_env="C++"><configuration><parameter default="0" description="&quot;bool value&quot;" name="randomized" policy="optional" type="int" /><parameter default="10" description="size of dimension" name="dim" policy="mandatory" type="int" /><parameter default="100" description="number of populations" name="pop" policy="mandatory" type="int" /><parameter default="1000" description="count of generations" name="gen" policy="mandatory" type="int" /><parameter default="0.9" description="a mutation constant" name="F" policy="optional" type="double" /><parameter default="0.9" description="a crossover constant" name="C" policy="optional" type="double" /><parameter default="0" description="" name="max_time" policy="optional" type="int" /><parameter default="-1" description="" name="print_frequency" policy="optional" type="int" /><parameter default="ackley" description="an optimized function" name="function" policy="mandatory" type="std::string" /><parameter default="0" description="" name="eval" policy="mandatory" type="int" /><parameter default="4" description="exchange gap" name="gap" policy="mandatory" type="int" /><build-option name="CC">g++</build-option><build-option name="LIBS" /><build-option name="CFLAGS">-O2 -I /home/sur096/projects/kaira_projects/differential-evolution</build-option><build-option name="OTHER_FILES">arg/utils/rng/cStandardRng.cpp
arg/utils/rng/cRanlux.cpp
arg/utils/cRandom.cpp
arg/utils/cCLParser.cpp
arg/core/cDebuggable.cpp
arg/core/cAmphorA.cpp
arg/algorithms/de/cParallelDE.cpp
arg/algorithms/de/cDE.cpp
cFunctions.cpp
de/cFuncDE.cpp</build-option><head-code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;cstdio&gt;

#include &lt;arg/utils/cCLParser.h&gt;
#include &lt;arg/core/cAmphorA.h&gt;
#include &lt;cFunctions.h&gt;
#include &lt;de/cFuncDE.h&gt;

#include &lt;arg/utils/rng/cRanlux.h&gt;

struct Best {

	Best() {
		vector_length = 0;
		fitness_length = 0;
		fitness = NULL;
		vector = NULL;
	}

	Best(int vector_length, int fitness_length, double *vector, double *fitness) {
		this-&gt;vector_length = vector_length;
		this-&gt;fitness_length = fitness_length;
		this-&gt;vector = new double[vector_length];
		memcpy(this-&gt;vector, vector, vector_length*sizeof(double));
		this-&gt;fitness = new double[fitness_length];
		memcpy(this-&gt;fitness, fitness, fitness_length*sizeof(double));
	}

	Best(const Best &amp;best) {
		vector_length = best.vector_length;
		fitness_length = best.fitness_length;
		vector = new double[vector_length];
		memcpy(vector, best.vector, vector_length*sizeof(double));
		fitness = new double[fitness_length];
		memcpy(fitness, best.fitness, fitness_length*sizeof(double));
	}

	Best&amp; operator=(const Best &amp;best) {
		if (vector != NULL) {
			delete [] vector;
		}

		if (fitness != NULL) {
			delete [] fitness;
		}
		vector_length = best.vector_length;
		fitness_length = best.fitness_length;
		vector = new double[vector_length];
		memcpy(vector, best.vector, vector_length*sizeof(double));
		fitness = new double[fitness_length];
		memcpy(fitness, best.fitness, fitness_length*sizeof(double));

		return *this;
	}

	~Best() {
		if (vector != NULL) {
			delete [] vector;
			vector = NULL;
		}
		if (fitness != NULL) {
			delete [] fitness;
			fitness = NULL;
		}
	}

	int vector_length;
	int fitness_length;
	double *vector;
	double *fitness;
};

typedef cFuncDE* Island;

/*int get_next(const ca::Context &amp;ctx, const int *waited) {
	return (ctx.process_id() + 1) % ctx.process_count();
}*/

double traceFitness(const Island island) {
	return island-&gt;BestFitness();
}

double traceValue(const int value) {
	return value;
}

namespace ca {
	std::string token_name(const Island &amp;island) {
		return "Island";
	}

	std::string token_name(const Best &amp;best) {
		return "Best";
	}

	void pack(Packer &amp;packer, Best &amp;best) {
		pack(packer, best.vector_length);
		pack(packer, best.fitness_length);
		pack(packer, best.vector, best.vector_length*sizeof(double));
		pack(packer, best.fitness, best.fitness_length*sizeof(double));
	}

	template&lt;&gt; Best unpack(Unpacker &amp;unpacker) {
		int vector_length = unpack&lt;int&gt;(unpacker);
		int fitness_length = unpack&lt;int&gt;(unpacker);

		double *v = (double *) unpack(unpacker, vector_length*sizeof(double));
		double *f = (double *) unpack(unpacker, fitness_length*sizeof(double));

		Best best(vector_length, fitness_length, v, f);
		return best;
	}
}</head-code></configuration><net id="101" name="Main" net-type="main"><edge from_item="107" id="111" inscription="c" inscription_x="42.0" inscription_y="-298.0" to_item="110"><point x="0" y="-286" /></edge><edge from_item="110" id="123" inscription="vec@ to_next" inscription_x="223.0" inscription_y="-301.0" to_item="122" /><edge from_item="122" id="124" inscription="vec" inscription_x="328.0" inscription_y="-238.0" to_item="116" /><edge bidirectional="true" from_item="116" id="126" inscription="island" inscription_x="271.0" inscription_y="-34.0" to_item="102"><point x="311" y="-19" /><point x="-232" y="-17" /><point x="-233" y="-163" /></edge><edge from_item="102" id="128" inscription="island" inscription_x="-264.0" inscription_y="-228.0" to_item="127" /><edge from_item="107" id="129" inscription="c" inscription_x="-187.0" inscription_y="-310.0" to_item="127"><point x="-73" y="-297" /><point x="-289" y="-296" /></edge><edge from_item="110" id="131" inscription="c+1" inscription_x="42.0" inscription_y="-231.0" to_item="107"><point x="95" y="-217" /></edge><edge from_item="107" id="109" inscription="c" inscription_x="-47.0" inscription_y="-148.0" to_item="103"><point x="-45" y="-172" /></edge><edge from_item="103" id="108" inscription="c+1" inscription_x="-107.0" inscription_y="-173.0" to_item="107"><point x="-99" y="-137" /></edge><edge bidirectional="true" from_item="102" id="105" inscription="island" inscription_x="-136.0" inscription_y="-102.0" to_item="103"><point x="-163" y="-86" /></edge><edge from_item="127" id="134" inscription="vec@0" inscription_x="-360.0" inscription_y="-158.0" to_item="133" /><edge from_item="133" id="136" inscription="[bulk, guard(size == ctx.process_count())] vectors" inscription_x="-250.0" inscription_y="-7.0" to_item="135" /><edge bidirectional="true" from_item="110" id="140" inscription="island" inscription_x="-174.0" inscription_y="-63.0" to_item="102"><point x="133" y="-46" /><point x="-198" y="-45" /><point x="-199" y="-113" /></edge><edge bidirectional="true" from_item="142" id="145" inscription="[bulk] waited" inscription_x="170.0" inscription_y="-348.0" to_item="110" /><edge from_item="127" id="146" inscription="[multicast] ctx.process_id()" inscription_x="-175.578136606" inscription_y="-418.30021692" to_item="142"><point x="-384" y="-401" /></edge><edge from_item="142" id="148" inscription="[bulk] process_id" inscription_x="267.001161519" inscription_y="-422.347212524" to_item="135"><point x="380" y="-405" /><point x="386" y="36" /></edge><place id="102" init_string="" name="Init" place_type="Island" radius="20" sx="0" sy="0" x="-162" y="-214"><code>	cFunctions func;
	func.SetFunction(cFunctions::FUNC_ACKLEY);

	if (!param::randomized()) {
		//arg::cStaticRandom::Seed(12349990);
		unsigned int seed[] = { 1, 2, 3, 4, 5, 10, 22, 35, 7, 1, 1 };
		
		arg::cStaticRandom::Seed(
			(unsigned int *) seed, 
			(unsigned int) sizeof(seed) / sizeof(unsigned int));
	}

	if (param::function() == "rastrigin") {
		func.SetFunction(cFunctions::FUNC_RASTRIGIN);
	} else if (param::function() == "dejong") {
		func.SetFunction(cFunctions::FUNC_DEJONG);
	} else if (param::function() == "griewank") {
		func.SetFunction(cFunctions::FUNC_GRIEWANK);
	} else if (param::function() == "ackley") {
		func.SetFunction(cFunctions::FUNC_ACKLEY);
	} else if (param::function() == "easom") {
		func.SetFunction(cFunctions::FUNC_EASOM);
	} else if (param::function() == "schwefel") {			
		func.SetFunction(cFunctions::FUNC_SCHWEFEL);
	} else if (param::function() == "rosenbrock") {
		func.SetFunction(cFunctions::FUNC_ROSENBROCK);
	}

	Island island;
	// initialization setting
	island = new cFuncDE(param::pop(), param::dim());
	island-&gt;Debug(false);
	island-&gt;MaxGenerations(param::gen());
	island-&gt;MaxEvaluations(param::eval());

	island-&gt;SetRange(func.RangeMin(), func.RangeMax());
	island-&gt;PrintFrequency(param::print_frequency());
	island-&gt;MaxTime(param::max_time());

	if (ctx.process_id() == 1) {
		island-&gt;F(0.3);
		island-&gt;C(0.8);
	} else if (ctx.process_id() == 2) {
		island-&gt;F(0.5);
		island-&gt;C(0.83);
	} else if (ctx.process_id() == 3) {
		island-&gt;F(0.7);
		island-&gt;F(0.86);
	} else {
		island-&gt;F(param::F()); // 0.9
		island-&gt;C(param::C()); // 0.9
	}

	// init de
	island-&gt;Init();

	place.add(island);
</code><trace name="traceFitness" return-type="double" /></place><place id="107" init_string="[1]" name="counter" place_type="int" radius="20" sx="0" sy="0" x="-73" y="-215" /><place id="122" init_string="" name="" place_type="Best" radius="20" sx="0" sy="0" x="307" y="-286" /><place id="133" init_string="" name="" place_type="Best" radius="20" sx="0" sy="0" x="-382" y="-109" /><transition guard="c % param::gap() == 0 &amp;&amp; ctx.process_count() &gt; 1" id="110" name="send" sx="70" sy="35" x="130" y="-286"><code>	arg::cArrayConst&lt;arg::cDE::t_FitnessIndexPair&gt; vector_info;
	var.island-&gt;SortPopulation(vector_info);

	int count = param::pop() * 0.5;
	var.vec.vector_length = param::dim() * count;
	var.vec.fitness_length = count;
	double *v = new double[var.vec.vector_length];
	double *f = new double[var.vec.fitness_length];
	double *pv = v;
	for (int i = 0; i &lt; count; i++) {
		f[i] = vector_info[i].fit;
		memcpy(pv, var.island-&gt;KairaGetArray(vector_info[i].idx), param::dim()*sizeof(double));
		pv += param::dim();
	}
	var.vec.vector = v;
	var.vec.fitness = f;
	
	
	int i = 1;
	int next = (ctx.process_id() + i) % ctx.process_count();
	for (ca::Token&lt;int &gt; *t = var.waited.begin(); t != NULL; t = var.waited.next(t)) {

		if (t-&gt;value != next) {
			break;
		}
		i++;
		next = (ctx.process_id() + i) % ctx.process_count();
	}
	var.to_next = next;
</code></transition><transition guard="" id="116" name="exchange" sx="70" sy="35" x="309" y="-179"><code>	var.island-&gt;KairaIntegrateVector(var.vec.vector, var.vec.fitness);
</code></transition><transition guard="c &gt; param::gen()" id="127" name="collect data" sx="70" sy="35" x="-383" y="-213"><code>	arg::cArrayConst&lt;double&gt; winner = var.island-&gt;Winner();
	var.vec.vector_length = winner.Count();
	var.vec.fitness_length = 1;
	double *v = new double[var.vec.vector_length];
	memcpy(v, winner.GetArray(0), var.vec.vector_length*sizeof(double));
	var.vec.vector = v;
	double *f = new double[var.vec.fitness_length];
	f[0] = var.island-&gt;BestFitness();
	var.vec.fitness = f;

	var.island-&gt;Finalize();
	delete var.island;
</code></transition><transition guard="c &lt;= param::gen() &amp;&amp; ((c % param::gap()) != 0 || ctx.process_count() == 1)" id="103" name="compute" sx="70" sy="35" x="-70" y="-87"><code>	var.island-&gt;KairaExecute();
</code></transition><transition guard="" id="135" name="write result" sx="70" sy="35" x="-380" y="40"><code>	double *best_solution;
	double fitness = -1;
	int length;
	for (ca::Token&lt;Best &gt; *t = var.vectors.begin(); t != NULL; t = var.vectors.next(t)) {
		if (fitness &gt; t-&gt;value.fitness[0] || fitness == -1) {
			fitness = t-&gt;value.fitness[0];
			best_solution = t-&gt;value.vector;
			length = t-&gt;value.vector_length;
		}
	}

	// print
	std::cout &lt;&lt; "Fitness = " &lt;&lt; fitness &lt;&lt; std::endl;
	std::cout &lt;&lt; "[";
	for (int i = 0; i &lt; length; i++) {
		std::cout &lt;&lt; best_solution[i] &lt;&lt; " ";
	}
	std::cout &lt;&lt; "]" &lt;&lt; std::endl;

	/*// write best-vector into file
	std::ofstream best_vector;
	best_vector.open("best-vector.csv", std::ios::out | std::ios::app);
	for (unsigned int i = 0; i &lt; length - 1; i++) {
		best_vector &lt;&lt; best_solution[i] &lt;&lt; ",";	
	}
	best_vector &lt;&lt; best_solution[length -1] &lt;&lt; "\n";
	best_vector.close();*/
	ctx.quit();
</code></transition><place id="142" init_string="" name="" place_type="int" radius="20" sx="0" sy="0" x="129" y="-404" /><area id="104" init-expr="ca::range(0, ctx.process_count())" name="" sx="193" sy="90" x="-203" y="-249" /></net></project>