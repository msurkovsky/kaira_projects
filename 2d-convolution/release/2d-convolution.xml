<project name="2d-convolution" root-directory="/home/sur096/projects/projects_in_kaira/2d-convolution" target_env="C++"><configuration><parameter default="24" description="Width of matrix" name="width" policy="mandatory" type="unsigned int" /><parameter default="24" description="height of matrix" name="height" policy="mandatory" type="unsigned int" /><parameter default="1" description="divide in along x axes" name="divide_x" policy="mandatory" type="int" /><parameter default="1" description="divide along y axes" name="divide_y" policy="mandatory" type="int" /><build-option name="CC">g++</build-option><build-option name="LIBS" /><build-option name="CFLAGS">-O2</build-option><head-code>#include &lt;matrix.h&gt;

namespace ca {

	std::string token_name(const Matrix&lt;float&gt; &amp;m) {
		return "matrix";
	}
	
	void pack(Packer &amp;packer, Matrix&lt;float&gt; &amp;m) {
		char *mem = m.serialize();
		pack(packer, m.get_size_of_serialized_data());
		pack(packer, mem, m.get_size_of_serialized_data());
		delete [] mem;
	}
	
	template&lt;&gt; Matrix&lt;float&gt; unpack(Unpacker &amp;unpacker) {
		unsigned int size_of_data = unpack&lt;unsigned int&gt;(unpacker);
		char *mem = (char *) unpack(unpacker, size_of_data);
		Matrix&lt;float&gt; matrix;
		matrix.deserialize(mem);
		return matrix;
	}
}</head-code></configuration><description>&lt;project target_env="C++"&gt;&lt;configuration&gt;&lt;parameter default="24" description="Width of matrix" name="width" policy="mandatory" type="unsigned int" /&gt;&lt;parameter default="24" description="height of matrix" name="height" policy="mandatory" type="unsigned int" /&gt;&lt;parameter default="1" description="divide in along x axes" name="divide_x" policy="mandatory" type="int" /&gt;&lt;parameter default="1" description="divide along y axes" name="divide_y" policy="mandatory" type="int" /&gt;&lt;build-option name="CC"&gt;g++&lt;/build-option&gt;&lt;build-option name="LIBS" /&gt;&lt;build-option name="CFLAGS"&gt;-O2&lt;/build-option&gt;&lt;head-code&gt;#include &amp;lt;matrix.h&amp;gt;

namespace ca {

	std::string token_name(const Matrix&amp;lt;float&amp;gt; &amp;amp;m) {
		return "matrix";
	}
	
	void pack(Packer &amp;amp;packer, Matrix&amp;lt;float&amp;gt; &amp;amp;m) {
		char *mem = m.serialize();
		pack(packer, m.get_size_of_serialized_data());
		pack(packer, mem, m.get_size_of_serialized_data());
		delete [] mem;
	}
	
	template&amp;lt;&amp;gt; Matrix&amp;lt;float&amp;gt; unpack(Unpacker &amp;amp;unpacker) {
		unsigned int size_of_data = unpack&amp;lt;unsigned int&amp;gt;(unpacker);
		char *mem = (char *) unpack(unpacker, size_of_data);
		Matrix&amp;lt;float&amp;gt; matrix;
		matrix.deserialize(mem);
		return matrix;
	}
}&lt;/head-code&gt;&lt;/configuration&gt;&lt;net id="101" name="Main" net-type="main"&gt;&lt;edge from_item="102" id="105" inscription="matrix" inscription_x="-410.0" inscription_y="-223.0" to_item="104" /&gt;&lt;edge from_item="104" id="108" inscription="[bulk] blocks" inscription_x="-242.0" inscription_y="-222.0" to_item="107" /&gt;&lt;edge bidirectional="true" from_item="109" id="114" inscription="mask" inscription_x="-356.0" inscription_y="-84.0" to_item="104"&gt;&lt;point x="-331" y="-69" /&gt;&lt;/edge&gt;&lt;edge from_item="116" id="119" inscription="c" inscription_x="-204.0" inscription_y="-132.0" to_item="115"&gt;&lt;point x="-233" y="-135" /&gt;&lt;/edge&gt;&lt;edge from_item="115" id="120" inscription="c+1" inscription_x="-253.0" inscription_y="-50.0" to_item="116"&gt;&lt;point x="-227" y="-38" /&gt;&lt;/edge&gt;&lt;edge from_item="107" id="122" inscription="block" inscription_x="-139.0" inscription_y="-157.0" to_item="115" /&gt;&lt;edge from_item="115" id="124" inscription="block@c" inscription_x="-130.0" inscription_y="-38.0" to_item="123" /&gt;&lt;edge from_item="123" id="126" inscription="block" inscription_x="-221.0" inscription_y="13.0" to_item="125" /&gt;&lt;edge bidirectional="true" from_item="109" id="127" inscription="mask" inscription_x="-382.0" inscription_y="13.0" to_item="125"&gt;&lt;point x="-428" y="26" /&gt;&lt;/edge&gt;&lt;edge from_item="125" id="129" inscription="block@0" inscription_x="-270.0" inscription_y="59.0" to_item="128" /&gt;&lt;edge from_item="128" id="131" inscription="[bulk, origin, guard(size == (param::divide_x() * param::divide_y()))] blocks" inscription_x="-106.0" inscription_y="140.0" to_item="130" /&gt;&lt;edge from_item="109" id="132" inscription="mask" inscription_x="-386.0" inscription_y="172.0" to_item="130"&gt;&lt;point x="-531" y="188" /&gt;&lt;/edge&gt;&lt;place id="102" init_string="" name="" place_type="Matrix&amp;lt;float&amp;gt;" radius="20" sx="0" sy="0" x="-564" y="-205"&gt;&lt;code&gt;	Matrix&amp;lt;float&amp;gt; matrix(param::width(), param::height());
	for (unsigned int i = 0; i &amp;lt; param::width(); i++) {
		for (unsigned int j = 0; j &amp;lt; param::height(); j++) {
			matrix.set(i, j, 2.0);
		}
	}
	place.add(matrix);
&lt;/code&gt;&lt;/place&gt;&lt;place id="107" init_string="" name="" place_type="Matrix&amp;lt;float&amp;gt;" radius="20" sx="0" sy="0" x="-161" y="-206" /&gt;&lt;place id="109" init_string="" name="convolution mask" place_type="Matrix&amp;lt;float&amp;gt;" radius="20" sx="73" sy="0" x="-572" y="-70"&gt;&lt;code&gt;	int mask_width = 3, mask_height = 3;
	float m[] = {
		0.0, 1.0, 0.0,
		1.0, 0.0, 1.0,
		0.0, 1.0, 0.0,
	};
	
	Matrix&amp;lt;float&amp;gt; mask(mask_width, mask_height, m);
	place.add(mask);
&lt;/code&gt;&lt;/place&gt;&lt;place id="116" init_string="[0]" name="counter" place_type="int" radius="20" sx="7" sy="0" x="-276" y="-86" /&gt;&lt;place id="123" init_string="" name="" place_type="Matrix&amp;lt;float&amp;gt;" radius="20" sx="0" sy="0" x="-158" y="25" /&gt;&lt;place id="128" init_string="" name="" place_type="Matrix&amp;lt;float&amp;gt;" radius="20" sx="0" sy="0" x="-302" y="109" /&gt;&lt;transition guard="" id="104" name="divide" sx="70" sy="35" x="-333" y="-206"&gt;&lt;code&gt;	unsigned int x_overlay = var.mask.get_width() / 2;
	unsigned int y_overlay = var.mask.get_height() / 2;

	unsigned int count = param::divide_x() * param::divide_y();	
	Matrix&amp;lt;float&amp;gt; *matrices = var.matrix.divide(
		param::divide_x(), param::divide_y(),
		x_overlay, y_overlay);
		
	for (unsigned int i = 0; i &amp;lt; count; i++) {
		var.blocks.add(matrices[i]);
	}
	delete [] matrices;
&lt;/code&gt;&lt;/transition&gt;&lt;transition guard="" id="115" name="distribute" sx="70" sy="35" x="-160" y="-90" /&gt;&lt;transition guard="" id="125" name="convolve" sx="70" sy="35" x="-303" y="27"&gt;&lt;code&gt;	var.block.convolve(var.mask);
&lt;/code&gt;&lt;/transition&gt;&lt;transition guard="" id="130" name="join" sx="70" sy="35" x="-304" y="188"&gt;&lt;code&gt;	unsigned int size = param::divide_x() * param::divide_y();
	Matrix&amp;lt;float&amp;gt; *matrices = new Matrix&amp;lt;float&amp;gt;[size];
	
	unsigned int x_overlay = var.mask.get_width() / 2;
	unsigned int y_overlay = var.mask.get_height() / 2;

	int i = 0;		
	for (ca::Token&amp;lt;Matrix&amp;lt;float&amp;gt; &amp;gt; *t = var.blocks.begin(); t != NULL; t = var.blocks.next(t)) {
		matrices[var.blocks_origins[i]] = t-&amp;gt;value;
		i++;
	}
	
	Matrix&amp;lt;float&amp;gt; matrix = Matrix&amp;lt;float&amp;gt;::join(
		param::width(), param::height(),
		param::divide_x(), param::divide_y(),
		matrices,
		x_overlay,
		y_overlay);
		
	/*for (unsigned int i = 0; i &amp;lt; param::width(); i++) {
		for (unsigned int j = 0; j &amp;lt; param::height(); j++) {
			printf("%.2f ", matrix.get(i, j));
		}
		printf("\n");
	}*/
	
	delete [] matrices;
	ctx.quit();
&lt;/code&gt;&lt;/transition&gt;&lt;area id="106" init-expr="[0]" name="" sx="165" sy="76" x="-599" y="-238" /&gt;&lt;area id="112" init-expr="ca::range(0, ctx.process_count())" name="" sx="204" sy="81" x="-600" y="-115" /&gt;&lt;/net&gt;&lt;/project&gt;</description><net id="101" name="Main"><place id="102" init-expr="" name="" type="Matrix&lt;float&gt;"><code>	Matrix&lt;float&gt; matrix(param::width(), param::height());
	for (unsigned int i = 0; i &lt; param::width(); i++) {
		for (unsigned int j = 0; j &lt; param::height(); j++) {
			matrix.set(i, j, 2.0);
		}
	}
	place.add(matrix);
</code></place><place id="107" init-expr="" name="" type="Matrix&lt;float&gt;" /><place id="109" init-expr="" name="convolution mask" type="Matrix&lt;float&gt;"><code>	int mask_width = 3, mask_height = 3;
	float m[] = {
		0.0, 1.0, 0.0,
		1.0, 0.0, 1.0,
		0.0, 1.0, 0.0,
	};
	
	Matrix&lt;float&gt; mask(mask_width, mask_height, m);
	place.add(mask);
</code></place><place id="116" init-expr="[0]" name="counter" type="int" /><place id="123" init-expr="" name="" type="Matrix&lt;float&gt;" /><place id="128" init-expr="" name="" type="Matrix&lt;float&gt;" /><transition guard="" id="104" name="divide"><code>	unsigned int x_overlay = var.mask.get_width() / 2;
	unsigned int y_overlay = var.mask.get_height() / 2;

	unsigned int count = param::divide_x() * param::divide_y();	
	Matrix&lt;float&gt; *matrices = var.matrix.divide(
		param::divide_x(), param::divide_y(),
		x_overlay, y_overlay);
		
	for (unsigned int i = 0; i &lt; count; i++) {
		var.blocks.add(matrices[i]);
	}
	delete [] matrices;
</code><edge-in expr="matrix" id="105" place-id="102" /><edge-in expr="mask" id="114" place-id="109" /><edge-out expr="[bulk] blocks" id="108" place-id="107" /><edge-out expr="mask" id="114" place-id="109" /></transition><transition guard="" id="115" name="distribute"><edge-in expr="c" id="119" place-id="116" /><edge-in expr="block" id="122" place-id="107" /><edge-out expr="c+1" id="120" place-id="116" /><edge-out expr="block@c" id="124" place-id="123" /></transition><transition guard="" id="125" name="convolve"><code>	var.block.convolve(var.mask);
</code><edge-in expr="block" id="126" place-id="123" /><edge-in expr="mask" id="127" place-id="109" /><edge-out expr="block@0" id="129" place-id="128" /><edge-out expr="mask" id="127" place-id="109" /></transition><transition guard="" id="130" name="join"><code>	unsigned int size = param::divide_x() * param::divide_y();
	Matrix&lt;float&gt; *matrices = new Matrix&lt;float&gt;[size];
	
	unsigned int x_overlay = var.mask.get_width() / 2;
	unsigned int y_overlay = var.mask.get_height() / 2;

	int i = 0;		
	for (ca::Token&lt;Matrix&lt;float&gt; &gt; *t = var.blocks.begin(); t != NULL; t = var.blocks.next(t)) {
		matrices[var.blocks_origins[i]] = t-&gt;value;
		i++;
	}
	
	Matrix&lt;float&gt; matrix = Matrix&lt;float&gt;::join(
		param::width(), param::height(),
		param::divide_x(), param::divide_y(),
		matrices,
		x_overlay,
		y_overlay);
		
	/*for (unsigned int i = 0; i &lt; param::width(); i++) {
		for (unsigned int j = 0; j &lt; param::height(); j++) {
			printf("%.2f ", matrix.get(i, j));
		}
		printf("\n");
	}*/
	
	delete [] matrices;
	ctx.quit();
</code><edge-in expr="[bulk, origin, guard(size == (param::divide_x() * param::divide_y()))] blocks" id="131" place-id="128" /><edge-in expr="mask" id="132" place-id="109" /></transition><area id="106" init-expr="[0]" name=""><place id="102" /></area><area id="112" init-expr="ca::range(0, ctx.process_count())" name=""><place id="109" /></area></net></project>